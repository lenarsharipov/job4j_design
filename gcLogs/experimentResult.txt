*********************************************************************************************************************************************
ParallelGC(-XX:+UseSerialGC -Xmx20m -Xms20m -Xlog:gc:gcLogs\Serial\logSerial.txt)

Запуск программы
При запуске программы в кучу поступило 10мб объектов. Во вкладке Sampler массив int[] занимал мин 530 тыс байт.
После малых сборок минимальный уровень используемой памяти опускался до 7мб. Затем поднимался до 9,5 мб. Данный цикл
выполнялся до создания массива int[] на 250 тыс. элементов.
Создание массива
На кучу выделено 20 мб, из которых около 13мб приходится на регион Old generation(tenured).
На регион Young generation около 7мб. Из них 8/10 на eden region (около 5+1/3мб), на survival(1+1/3 мб).
Создаём массив размером 250 тыс элементов. Он займёт около 1мб памяти.
250 тыс элементов * 8 байт (размер переменной типа int) + 16 байт (размер заголовка объекта в 64-х разрядной системе) = 1 000 016 байт.
Минимальный размер используемой кучи поднялся с 7мб до 8мб.  Размер массива int[] изменился c 530 тыс байт до 1,5 мб.
Так как объем объекта (1мб) выше выделяемого объёма региона survival0/survival1, то объект сразу размещается в
регион old generation(tenured).
Процессор был задействован на 0,3%

Сортировка слиянием
Делаем сортировку слиянием и видим, что объем int[] вырос на 3_300_000+/- байт. Учитываем, что мы также создали
клон массива(1000000+ байт). И много памяти потребовалось при разбиении на массивы (почти 2300000+ байт).
Минимальный размер используемой памяти вырос с 8мб до 10,5мб.  Процессор был задействован на 3%.
ParallelGC продолжает проводить малые сборки. Время сортировки - 60 мс.

Сортировка методом вставки
Теперь делаем сортировку вставками. Можем наблюдать, что хип вырос на размер массива, но существенных накладных
расходов на данную операцию по сравнению с merge нет
(мы не создаём массивы, а меняем ссылки у элементов (если это потребуется) + локальные переменные):

Минимальный размер используемой памяти и соответственно размер массива int[] остались на прежнем уровне.
Процессор был задействован на 26%.
ParallelGC продолжает проводить малые сборки. Время сортировки - 60 с.

Сортировка пузырьком
Минимальный размер используемой памяти вырос с 10,5мб до 11,5мб.  Размер массива int[] 4,5 мб. Процессор был задействован
в среднем на 25% на протяжении 1мин 50 сек.
ParallelGC продолжает проводить малые сборки.

Major GC
Для выполнения большой сборки мусора пришлось выполнить ещё две сортировки слиянием, так как она больше остальных
сортировок нагружает кучу. После совершения сборки минимально используемый размер кучи составил 8,3мб, размер массива int[] 3.1мб.

ЛОГ:
[1319.881s][info][gc] GC(61) Pause Full (Ergonomics) 13M->6M(19M) 25.997ms


*********************************************************************************************************************************************
G1GC(-XX:+UseG1GC -Xmx20m -Xms20m -Xlog:gc:gcLogs\G1\logG1.txt)

G1GC отличается от от Serial, Parallel GC по нескольким параметрам. G1 разбивает кучу на множество регионов,
одинаковых по размеру. Разбиение на old(tenured) и young(eden + survival) происходит логически, а не физически.
К тому же регионы могут менять свою принадлежность от региона к региону.
Полная сборка мусора, в G1 называется “mixed”,  устроена подругому. G1 - использует Concurrent. Соответственно,
параллельно с работой программы, проходит процесс под названием “marking cycle”(цикл пометки), в котором есть следующие этапы:
    1.Initial mark(Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых сборок.
      (roots - ссылки из стеков потоков, статические члены классов и т.д.))
    2.Concurrent marking(Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного приложения)
    3.Remark(Дополнительный поиск не учтённых ранее живых объектов (с остановкой основного приложения))
    4.Cleanup:
        A.Очистка вспомогательных структур учёта ссылок на объекты с остановкой основного приложения
        B.Поиск пустых регионов, которые уже можно использовать для размещения новых объектов

Соответственно, паузы на очистку короче, ресурсов необходимо больше.

Запуск программы
При запуске программы в кучу поступило 10мб объектов. Во вкладке Sampler массив int[] занимал мин 0,42 мб.
После малых сборок минимальный уровень используемой памяти опускался до 7мб. Затем поднимался до 13,5 мб.
Данный цикл выполнялся до создания массива int[] на 250 тыс. элементов.

Создание массива
Создаём массив размером 250 тыс элементов. Он займёт около 1мб памяти.  Объект такого размера в данных условиях
является объектом типа humongous object(громадный объект), поэтому он помещается сразу в регион old generation.
Размер массива достигает 1,5мб. Куча 8,3мб. G1 продолжает обходиться малыми сборками.

ЛОГ:
[540.375s][info][gc] GC(20) Pause Young (Concurrent Start) (G1 Humongous Allocation) 12M->10M(20M) 1.047ms

Сортировка слиянием
Делаем сортировку слиянием и видим, что объем int[] вырос на 3_300_000+/- байт.
Учитываем, что мы также создали клон массива(1000000+ байт).
И много памяти потребовалось при разбиении на массивы (почти 2300000+ байт).
Минимальный размер используемой памяти вырос с 8мб до 10мб.  Процессор был задействован на 3%.
G1 выполнил большую сборку, согласно своему алгоритму - сначала выполнился “marking cycle”, а затем сборка мусора.

ЛОГ:
[540.376s][info][gc] GC(21) Concurrent Mark Cycle
[540.390s][info][gc] GC(21) Pause Remark 11M->11M(20M) 4.693ms
[540.395s][info][gc] GC(21) Pause Cleanup 11M->11M(20M) 0.075ms
[540.395s][info][gc] GC(21) Concurrent Mark Cycle 19.715ms
[570.255s][info][gc] GC(22) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 16M->8M(20M) 4.586ms
[577.430s][info][gc] GC(23) Pause Young (Mixed) (G1 Evacuation Pause) 9M->7M(20M) 11.260ms

Куча стала 7,8мб, массив имеет размер 1,5мб.

Сортировка методом вставки
Теперь делаем сортировку вставками. Можем наблюдать, что куча не изменилась. Минимальный размер используемой
памяти и соответственно размер массива int[] остались на прежнем уровне. Процессор был задействован на 26%.
G1 продолжает проводить малые сборки. Время сортировки - 66 с.

Сортировка пузырьком
Минимальный размер используемой памяти вырос с 7,8мб до 9мб.  Размер массива int[] 2,5 мб.
Процессор был задействован в среднем на 25% на протяжении 1мин 54 сек.


*********************************************************************************************************************************************
ZGC(-XX:+UseZGC -Xmx24m -Xms24m -Xlog:gc:gcLogs\zgc\logZGC.txt)

В ZGC  куча не делится на регионы. Данный сборщик способен работать с кучами размером до 16тб.
Он  Parallel, Concurrent, Copying, т.е. мусор помечается параллельно с работой приложения.
Паузы на малую сборку составляют субмиллисекунды. Пометки объектов на удалении происходит за счёт
окрашивания этих объектов. Устройство кучи отличается координально от предыдущих сборщиков.

Запуск программы
При запуске программы в кучу поступило 18мб объектов. Во вкладке Sampler массив int[] занимал мин 0,14 мб.
После малых сборок минимальный уровень используемой памяти находился в диапазоне 10мб - 14мб.
Данный цикл выполнялся до создания массива int[] на 250 тыс. элементов.

Создание массива
Создаём массив размером 250 тыс элементов. Он займёт около 1мб памяти.  Размер массива достиг 1,14мб.
Размер используемой кучи находится в диапазоне 10мб - 12мб. ZGC продолжает обходиться малыми сборками.


Сортировка слиянием
Делаем сортировку слиянием и видим, что объем int[] вырос до 2,14мб. Учитываем, что мы также создали
клон массива(1000000+ байт). Затем мусор был убран и размер массива вернулся к прежнему значению = 1,14мб.
Здесь произошла большая сборка и минимальный размер используемой памяти вернулся на прежний уровень.

ЛОГ:
[325.521s][info][gc] GC(32) Garbage Collection (Proactive) 14M(58%)->10M(42%)
[330.322s][info][gc] Allocation Stall (main) 7.703ms
[330.324s][info][gc] GC(33) Garbage Collection (Proactive) 16M(67%)->22M(92%)
[330.351s][info][gc] Allocation Stall (main) 23.844ms
[330.353s][info][gc] GC(34) Garbage Collection (Allocation Stall) 24M(100%)->16M(67%)
[330.383s][info][gc] Allocation Stall (main) 19.895ms
[330.385s][info][gc] GC(35) Garbage Collection (Allocation Stall) 24M(100%)->16M(67%)


Сортировка методом вставки
Теперь делаем сортировку вставками. Можем наблюдать, что используемая память сначала увеличилась,
затем вернулась к прежним значениям. Минимальный размер используемой памяти и соответственно размер
массива int[] остались на прежнем уровне. Процессор был задействован на 25%.
ZGC продолжает проводить малые сборки. Время сортировки - 53 с.

Сортировка пузырьком
Делаем сортировку пузырьком. Объем int[] вырос до 2,14мб.  Затем мусор был убран и размер массива вернулся
к прежнему значению = 1,14мб. Используемая память поднималась до 16мб, затем за счёт малых сборок она вернулась
в диапазон 10-12мб.